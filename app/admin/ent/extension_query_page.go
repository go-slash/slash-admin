// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

const errInvalidPage = "INVALID_PAGE"

const (
	listField     = "list"
	pageNumField  = "pageNum"
	pageSizeField = "pageSize"
)

type PageDetails struct {
	Page  int `json:"page"`
	Limit int `json:"limit"`
	Total int `json:"total"`
}

func validatePageNumPageSize(pageNum int, pageSize int) (err *gqlerror.Error) {
	switch {
	case pageNum <= 0:
		err = &gqlerror.Error{
			Message: "`pageNum` cannot be less than one.",
		}
		errcode.Set(err, errInvalidPage)
	case pageSize <= 0:
		err = &gqlerror.Error{
			Message: "`pageSize` cannot be less than one.",
		}
		errcode.Set(err, errInvalidPage)
	}
	return err
}

// SysApiPageList is SysApi PageList result.
type SysApiPageList struct {
	List        []*SysApi    `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (sa *SysApiQuery) Page(
	ctx context.Context, pageNum int, pageSize int, opts ...SysApiPaginateOption,
) (*SysApiPageList, error) {
	if err := validatePageNumPageSize(pageNum, pageSize); err != nil {
		return nil, err
	}
	pager, err := newSysApiPager(opts)
	if err != nil {
		return nil, err
	}

	if sa, err = pager.applyFilter(sa); err != nil {
		return nil, err
	}

	ret := &SysApiPageList{}

	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Limit: pageSize,
	}

	count, err := sa.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = count

	direction := pager.order.Direction
	sa = sa.Order(direction.orderFunc(pager.order.Field.field))
	if pager.order.Field != DefaultSysApiOrder.Field {
		sa = sa.Order(direction.orderFunc(DefaultSysApiOrder.Field.field))
	}

	sa = sa.Offset((pageNum - 1) * pageSize).Limit(pageSize)
	list, err := sa.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

// SysDictionaryPageList is SysDictionary PageList result.
type SysDictionaryPageList struct {
	List        []*SysDictionary `json:"list"`
	PageDetails *PageDetails     `json:"pageDetails"`
}

func (sd *SysDictionaryQuery) Page(
	ctx context.Context, pageNum int, pageSize int, opts ...SysDictionaryPaginateOption,
) (*SysDictionaryPageList, error) {
	if err := validatePageNumPageSize(pageNum, pageSize); err != nil {
		return nil, err
	}
	pager, err := newSysDictionaryPager(opts)
	if err != nil {
		return nil, err
	}

	if sd, err = pager.applyFilter(sd); err != nil {
		return nil, err
	}

	ret := &SysDictionaryPageList{}

	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Limit: pageSize,
	}

	count, err := sd.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = count

	direction := pager.order.Direction
	sd = sd.Order(direction.orderFunc(pager.order.Field.field))
	if pager.order.Field != DefaultSysDictionaryOrder.Field {
		sd = sd.Order(direction.orderFunc(DefaultSysDictionaryOrder.Field.field))
	}

	sd = sd.Offset((pageNum - 1) * pageSize).Limit(pageSize)
	list, err := sd.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

// SysDictionaryDetailPageList is SysDictionaryDetail PageList result.
type SysDictionaryDetailPageList struct {
	List        []*SysDictionaryDetail `json:"list"`
	PageDetails *PageDetails           `json:"pageDetails"`
}

func (sdd *SysDictionaryDetailQuery) Page(
	ctx context.Context, pageNum int, pageSize int, opts ...SysDictionaryDetailPaginateOption,
) (*SysDictionaryDetailPageList, error) {
	if err := validatePageNumPageSize(pageNum, pageSize); err != nil {
		return nil, err
	}
	pager, err := newSysDictionaryDetailPager(opts)
	if err != nil {
		return nil, err
	}

	if sdd, err = pager.applyFilter(sdd); err != nil {
		return nil, err
	}

	ret := &SysDictionaryDetailPageList{}

	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Limit: pageSize,
	}

	count, err := sdd.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = count

	direction := pager.order.Direction
	sdd = sdd.Order(direction.orderFunc(pager.order.Field.field))
	if pager.order.Field != DefaultSysDictionaryDetailOrder.Field {
		sdd = sdd.Order(direction.orderFunc(DefaultSysDictionaryDetailOrder.Field.field))
	}

	sdd = sdd.Offset((pageNum - 1) * pageSize).Limit(pageSize)
	list, err := sdd.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

// SysMenuPageList is SysMenu PageList result.
type SysMenuPageList struct {
	List        []*SysMenu   `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (sm *SysMenuQuery) Page(
	ctx context.Context, pageNum int, pageSize int, opts ...SysMenuPaginateOption,
) (*SysMenuPageList, error) {
	if err := validatePageNumPageSize(pageNum, pageSize); err != nil {
		return nil, err
	}
	pager, err := newSysMenuPager(opts)
	if err != nil {
		return nil, err
	}

	if sm, err = pager.applyFilter(sm); err != nil {
		return nil, err
	}

	ret := &SysMenuPageList{}

	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Limit: pageSize,
	}

	count, err := sm.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = count

	direction := pager.order.Direction
	sm = sm.Order(direction.orderFunc(pager.order.Field.field))
	if pager.order.Field != DefaultSysMenuOrder.Field {
		sm = sm.Order(direction.orderFunc(DefaultSysMenuOrder.Field.field))
	}

	sm = sm.Offset((pageNum - 1) * pageSize).Limit(pageSize)
	list, err := sm.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

// SysMenuParamPageList is SysMenuParam PageList result.
type SysMenuParamPageList struct {
	List        []*SysMenuParam `json:"list"`
	PageDetails *PageDetails    `json:"pageDetails"`
}

func (smp *SysMenuParamQuery) Page(
	ctx context.Context, pageNum int, pageSize int, opts ...SysMenuParamPaginateOption,
) (*SysMenuParamPageList, error) {
	if err := validatePageNumPageSize(pageNum, pageSize); err != nil {
		return nil, err
	}
	pager, err := newSysMenuParamPager(opts)
	if err != nil {
		return nil, err
	}

	if smp, err = pager.applyFilter(smp); err != nil {
		return nil, err
	}

	ret := &SysMenuParamPageList{}

	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Limit: pageSize,
	}

	count, err := smp.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = count

	direction := pager.order.Direction
	smp = smp.Order(direction.orderFunc(pager.order.Field.field))
	if pager.order.Field != DefaultSysMenuParamOrder.Field {
		smp = smp.Order(direction.orderFunc(DefaultSysMenuParamOrder.Field.field))
	}

	smp = smp.Offset((pageNum - 1) * pageSize).Limit(pageSize)
	list, err := smp.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

// SysOauthProviderPageList is SysOauthProvider PageList result.
type SysOauthProviderPageList struct {
	List        []*SysOauthProvider `json:"list"`
	PageDetails *PageDetails        `json:"pageDetails"`
}

func (sop *SysOauthProviderQuery) Page(
	ctx context.Context, pageNum int, pageSize int, opts ...SysOauthProviderPaginateOption,
) (*SysOauthProviderPageList, error) {
	if err := validatePageNumPageSize(pageNum, pageSize); err != nil {
		return nil, err
	}
	pager, err := newSysOauthProviderPager(opts)
	if err != nil {
		return nil, err
	}

	if sop, err = pager.applyFilter(sop); err != nil {
		return nil, err
	}

	ret := &SysOauthProviderPageList{}

	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Limit: pageSize,
	}

	count, err := sop.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = count

	direction := pager.order.Direction
	sop = sop.Order(direction.orderFunc(pager.order.Field.field))
	if pager.order.Field != DefaultSysOauthProviderOrder.Field {
		sop = sop.Order(direction.orderFunc(DefaultSysOauthProviderOrder.Field.field))
	}

	sop = sop.Offset((pageNum - 1) * pageSize).Limit(pageSize)
	list, err := sop.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

// SysRolePageList is SysRole PageList result.
type SysRolePageList struct {
	List        []*SysRole   `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (sr *SysRoleQuery) Page(
	ctx context.Context, pageNum int, pageSize int, opts ...SysRolePaginateOption,
) (*SysRolePageList, error) {
	if err := validatePageNumPageSize(pageNum, pageSize); err != nil {
		return nil, err
	}
	pager, err := newSysRolePager(opts)
	if err != nil {
		return nil, err
	}

	if sr, err = pager.applyFilter(sr); err != nil {
		return nil, err
	}

	ret := &SysRolePageList{}

	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Limit: pageSize,
	}

	count, err := sr.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = count

	direction := pager.order.Direction
	sr = sr.Order(direction.orderFunc(pager.order.Field.field))
	if pager.order.Field != DefaultSysRoleOrder.Field {
		sr = sr.Order(direction.orderFunc(DefaultSysRoleOrder.Field.field))
	}

	sr = sr.Offset((pageNum - 1) * pageSize).Limit(pageSize)
	list, err := sr.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

// SysTokenPageList is SysToken PageList result.
type SysTokenPageList struct {
	List        []*SysToken  `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (st *SysTokenQuery) Page(
	ctx context.Context, pageNum int, pageSize int, opts ...SysTokenPaginateOption,
) (*SysTokenPageList, error) {
	if err := validatePageNumPageSize(pageNum, pageSize); err != nil {
		return nil, err
	}
	pager, err := newSysTokenPager(opts)
	if err != nil {
		return nil, err
	}

	if st, err = pager.applyFilter(st); err != nil {
		return nil, err
	}

	ret := &SysTokenPageList{}

	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Limit: pageSize,
	}

	count, err := st.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = count

	direction := pager.order.Direction
	st = st.Order(direction.orderFunc(pager.order.Field.field))
	if pager.order.Field != DefaultSysTokenOrder.Field {
		st = st.Order(direction.orderFunc(DefaultSysTokenOrder.Field.field))
	}

	st = st.Offset((pageNum - 1) * pageSize).Limit(pageSize)
	list, err := st.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

// SysUserPageList is SysUser PageList result.
type SysUserPageList struct {
	List        []*SysUser   `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (su *SysUserQuery) Page(
	ctx context.Context, pageNum int, pageSize int, opts ...SysUserPaginateOption,
) (*SysUserPageList, error) {
	if err := validatePageNumPageSize(pageNum, pageSize); err != nil {
		return nil, err
	}
	pager, err := newSysUserPager(opts)
	if err != nil {
		return nil, err
	}

	if su, err = pager.applyFilter(su); err != nil {
		return nil, err
	}

	ret := &SysUserPageList{}

	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Limit: pageSize,
	}

	count, err := su.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = count

	direction := pager.order.Direction
	su = su.Order(direction.orderFunc(pager.order.Field.field))
	if pager.order.Field != DefaultSysUserOrder.Field {
		su = su.Order(direction.orderFunc(DefaultSysUserOrder.Field.field))
	}

	su = su.Offset((pageNum - 1) * pageSize).Limit(pageSize)
	list, err := su.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}
